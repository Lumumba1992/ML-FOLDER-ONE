f <- with(grid, x^2 - y^2 + z^2 - 1)
# Find points close to 0 (within a tolerance)
eps <- 0.05  # Adjust the tolerance as needed
surface_points <- grid[abs(f) < eps, ]
# Open a 3D plot
rgl.open()
# Plot the points satisfying the equation
plot3d(surface_points$x, surface_points$y, surface_points$z, col = "lightblue", size = 1, type = "s")
library(rgl)
# Create a grid for x, y, and z
n <- 50
x <- seq(-2, 2, length.out = n)
y <- seq(-2, 2, length.out = n)
z <- seq(-2, 2, length.out = n)
# Create 3D mesh
grid <- expand.grid(x = x, y = y, z = z)
# Define the equation: x^2 - y^2 + z^2 - 1 = 0
f <- with(grid, x^2 - y^2 + z^2 - 1)
# Find points close to 0 to draw the surface
eps <- 0.05  # Tolerance for plotting points
surface_points <- grid[abs(f) < eps, ]
# Plot in 3D using rgl
plot3d(surface_points$x, surface_points$y, surface_points$z, col = "blue", size = 1, type = "s")
# Load the rgl package
library(rgl)
# Define a grid for x and z
x <- seq(-2, 2, length=100)
z <- seq(-2, 2, length=100)
# Create a meshgrid for x and z
X <- outer(x, rep(1, length(z)))
Z <- outer(rep(1, length(x)), z)
# Solve for y^2 = x^2 + z^2 - 1 to get the y values
Y_pos <- sqrt(X^2 + Z^2 - 1)  # Positive branch for y
Y_neg <- -sqrt(X^2 + Z^2 - 1) # Negative branch for y
# Remove NA values (where x^2 - y^2 + z^2 < 1, it's undefined)
Y_pos[is.na(Y_pos)] <- 0
Y_neg[is.na(Y_neg)] <- 0
# Open a 3D plot
rgl.open()
# Plot both halves of the hyperboloid
rgl.surface(X, Y_pos, Z, color="lightblue", alpha=0.6)  # Top half
rgl.surface(X, Y_neg, Z, color="lightblue", alpha=0.6)  # Bottom half
# Set viewpoint for interactive rotation
rgl.viewpoint(theta = 40, phi = 30)
library(plotly)
# Define the range and step for x and y
x <- seq(-10, 10, length.out = 100)
y <- seq(-10, 10, length.out = 100)
xy <- expand.grid(x = x, y = y)
# Calculate z using the equation x^2 - y^2 + z^2 = 0
z <- sqrt(y^2 - x^2)
# Remove complex numbers (when y^2 < x^2)
z[is.na(z)] <- 0
# Create the 3D plot
fig <- plot_ly(x = ~xy$x, y = ~xy$y, z = ~z, type = 'mesh3d')
# Add surface plot
fig <- fig %>%
add_trace(z = ~z, type = 'surface', colorscale = 'Viridis')
# Set plot layout
fig <- fig %>%
layout(scene = list(
xaxis = list(title = 'X'),
yaxis = list(title = 'Y'),
zaxis = list(title = 'Z')
))
# Show plot
fig
# Load the rgl package
library(rgl)
# Define a grid for x and z
x <- seq(-2, 2, length=100)
z <- seq(-2, 2, length=100)
# Create a meshgrid for x and z
X <- outer(x, rep(1, length(z)))
Z <- outer(rep(1, length(x)), z)
# Solve for y^2 = x^2 + z^2 - 1 to get the y values
Y_pos <- sqrt(X^2 + Z^2 - 1)  # Positive branch for y
Y_neg <- -sqrt(X^2 + Z^2 - 1) # Negative branch for y
# Remove NA values (where x^2 + z^2 < 1, it's undefined)
Y_pos[is.nan(Y_pos)] <- 0
Y_neg[is.nan(Y_neg)] <- 0
# Open a 3D plot
rgl.open()
# Plot both halves of the hyperboloid
rgl.surface(X, Y_pos, Z, color="lightblue", alpha=0.6)  # Top half
rgl.surface(X, Y_neg, Z, color="lightblue", alpha=0.6)  # Bottom half
# Set viewpoint for interactive rotation
rgl.viewpoint(theta = 40, phi = 30)
# Optional: Add axes labels
rgl.axes()
# Load the rgl package
library(rgl)
# Define a grid for x and z
x <- seq(-2, 2, length=100)
z <- seq(-2, 2, length=100)
# Create a meshgrid for x and z
X <- outer(x, rep(1, length(z)))
Z <- outer(rep(1, length(x)), z)
# Solve for y^2 = x^2 + z^2 - 1 to get the y values
Y_pos <- sqrt(X^2 + Z^2 - 1)  # Positive branch for y
Y_neg <- -sqrt(X^2 + Z^2 - 1) # Negative branch for y
# Remove NA values (where x^2 - y^2 + z^2 < 1, it's undefined)
Y_pos[is.na(Y_pos)] <- 0
Y_neg[is.na(Y_neg)] <- 0
# Open a 3D plot
rgl.open()
# Plot both halves of the hyperboloid
rgl.surface(X, Y_pos, Z, color="lightblue", alpha=0.6)  # Top half
rgl.surface(X, Y_neg, Z, color="lightblue", alpha=0.6)  # Bottom half
# Set viewpoint for interactive rotation
rgl.viewpoint(theta = 40, phi = 30)
# Load the rgl package
library(rgl)
# Define a grid for x and z
x <- seq(-2, 2, length=100)
z <- seq(-2, 2, length=100)
# Create a meshgrid for x and z
X <- outer(x, rep(1, length(z)))
Z <- outer(rep(1, length(x)), z)
# Solve for y^2 = x^2 + z^2 to get the y values
Y_pos <- sqrt(X^2 + Z^2)  # Positive branch for y
Y_neg <- -sqrt(X^2 + Z^2) # Negative branch for y
# Open a 3D plot
rgl.open()
# Plot both sheets of the hyperboloid
rgl.surface(X, Y_pos, Z, color="lightblue", alpha=0.6)  # Top sheet
rgl.surface(X, Y_neg, Z, color="lightblue", alpha=0.6)  # Bottom sheet
# Set viewpoint for interactive rotation
rgl.viewpoint(theta = 40, phi = 30)
# Optional: Add axes labels
rgl.axes()
# Load the rgl package
library(rgl)
# Define a grid for x and z
x <- seq(-2, 2, length=100)
z <- seq(-2, 2, length=100)
# Create a meshgrid for x and z
X <- outer(x, rep(1, length(z)))
Z <- outer(rep(1, length(x)), z)
# Solve for y^2 = x^2 + z^2 to get the y values
Y_pos <- sqrt(X^2 + Z^2)  # Positive branch for y
Y_neg <- -sqrt(X^2 + Z^2) # Negative branch for y
# Open a 3D plot
rgl.open()
# Plot both sheets of the hyperboloid
rgl.surface(X, Y_pos, Z, color="lightblue", alpha=0.6)  # Top sheet
rgl.surface(X, Y_neg, Z, color="lightblue", alpha=0.6)  # Bottom sheet
# Set viewpoint for interactive rotation
rgl.viewpoint(theta = 40, phi = 30)
# Optional: Add axes labels
#rgl.axes()
#rgl.title("Hyperboloid of Two Sheets")
# Load the rgl package
library(rgl)
# Define a grid for x and y
x <- seq(-2, 2, length = 100)
y <- seq(-2, 2, length = 100)
# Create a meshgrid for x and y
X <- outer(x, rep(1, length(y)))
Y <- outer(rep(1, length(x)), y)
# Calculate z using the equation x^2 - y^2 + z + 1 = 0
# Rearranging gives z = -x^2 + y^2 - 1
Z <- -X^2 + Y^2 - 1
# Open a 3D plot
rgl.open()
# Plot the surface
rgl.surface(X, Y, Z, color = "lightblue", alpha = 0.6)
# Set viewpoint for interactive rotation
rgl.viewpoint(theta = 40, phi = 30)
# Optional: Add axes labels
rgl.axes()
# Load the rgl package
library(rgl)
# Define a grid for x and y
x <- seq(-2, 2, length = 100)
y <- seq(-2, 2, length = 100)
# Create a meshgrid for x and y
X <- outer(x, rep(1, length(y)))
Y <- outer(rep(1, length(x)), y)
# Calculate z using the equation x^2 - y^2 + z + 1 = 0
# Rearranging gives z = -x^2 + y^2 - 1
Z <- -X^2 + Y^2 - 1
# Open a 3D plot
rgl.open()
# Plot the surface
rgl.surface(X, Y, Z, color = "lightblue", alpha = 0.6)
# Set viewpoint for interactive rotation
rgl.viewpoint(theta = 40, phi = 30)
# Optional: Add axes labels
rgl.axes()
# Load the rgl package
library(rgl)
# Define the parameters
theta <- seq(0, 2*pi, length=100)
phi <- seq(-pi/2, pi/2, length=100)
# Create a meshgrid for theta and phi
Theta <- outer(theta, rep(1, length(phi)))
Phi <- outer(rep(1, length(theta)), phi)
# Parametric equations for the hyperboloids (imaginary surface visualization)
x_top <- cos(Theta) * sqrt(cosh(Phi)^2 - 1)
y_top <- sin(Theta) * sqrt(cosh(Phi)^2 - 1)
z_top <- sinh(Phi)
x_bottom <- cos(Theta) * sqrt(1 - cosh(Phi)^2)
y_bottom <- sin(Theta) * sqrt(1 - cosh(Phi)^2)
z_bottom <- sinh(Phi)
# Open a 3D plot
rgl.open()
# Plot the top part
rgl.surface(x_top, y_top, z_top, color="lightblue", alpha=0.8)
# Plot the bottom part
rgl.surface(x_bottom, y_bottom, z_bottom, color="orange", alpha=0.8)
# Add gridlines and box for context
rgl.bbox(color = c("gray", "gray"), emission="gray")
rgl.axes(color="black", xlab="x", ylab="y", zlab="z")
# Load the rgl package
library(rgl)
# Define the parameters
theta <- seq(0, 2*pi, length=100)
phi <- seq(-pi/2, pi/2, length=100)
# Create a meshgrid for theta and phi
Theta <- outer(theta, rep(1, length(phi)))
Phi <- outer(rep(1, length(theta)), phi)
# Parametric equations for the hyperboloids (imaginary surface visualization)
x_top <- cos(Theta) * sqrt(cosh(Phi)^2 - 1)
y_top <- sin(Theta) * sqrt(cosh(Phi)^2 - 1)
z_top <- sinh(Phi)
x_bottom <- cos(Theta) * sqrt(1 - cosh(Phi)^2)
y_bottom <- sin(Theta) * sqrt(1 - cosh(Phi)^2)
z_bottom <- sinh(Phi)
# Open a 3D plot
rgl.open()
# Plot the top part
rgl.surface(x_top, y_top, z_top, color="lightblue", alpha=0.8)
# Plot the bottom part
rgl.surface(x_bottom, y_bottom, z_bottom, color="orange", alpha=0.8)
library(plot3D)
# Define a grid for theta and phi
theta <- seq(0, 2*pi, length=100)
phi <- seq(0, pi, length=100)
# Generate x, y, z for the sphere
x <- outer(sin(phi), cos(theta))
y <- outer(sin(phi), sin(theta))
z <- outer(cos(phi), rep(1, length(theta)))
# Plot the sphere using scatter3D
scatter3D(x, y, z, colvar = z, col = "blue", pch = 20, theta = 60, phi = 20,
xlab = "X", ylab = "Y", zlab = "Z", main="3D Sphere Plot")
library(rgl)
# Define a grid for x and y
theta <- seq(0, 2*pi, length=100)
phi <- seq(0, pi, length=100)
# Generate x, y, z for the sphere
x <- outer(sin(phi), cos(theta))
y <- outer(sin(phi), sin(theta))
z <- outer(cos(phi), rep(1, length(theta)))
# Plot the sphere
rgl.open()
rgl.spheres(0, 0, 0, radius = 1, color = "blue", alpha = 0.6)
rgl.surface(x, y, z, color="lightblue", alpha=0.6)
rgl.viewpoint(theta = 40, phi = 30)
# Load the rgl package
library(rgl)
# Define a grid for theta and y
theta <- seq(0, 2*pi, length=100)  # Angle around the cylinder
y <- seq(-2, 2, length=100)  # Height of the cylinder (y-axis)
# Generate x, z for the cylinder (x^2 + z^2 = 1 is a circle in the x-z plane)
x <- cos(theta)
z <- sin(theta)
# Create 3D grid for the cylinder's surface by repeating x, z over the height (y)
X <- outer(x, rep(1, length(y)))  # Repeat the x values for each y
Z <- outer(z, rep(1, length(y)))  # Repeat the z values for each y
Y <- outer(rep(1, length(theta)), y)  # Repeat the y values along the cylinder's height
# Open an interactive 3D plot and plot the cylinder
rgl.open()
rgl.surface(X, Y, Z, color="lightblue", alpha=0.6)
# Set viewpoint for interactive rotation
rgl.viewpoint(theta = 40, phi = 30)
# Load the rgl package
library(rgl)
# Define a grid for x and z
x <- seq(-2, 2, length=100)
z <- seq(-2, 2, length=100)
# Create a meshgrid for x and z
X <- outer(x, rep(1, length(z)))
Z <- outer(rep(1, length(x)), z)
# Solve for y^2 = x^2 + z^2 - 1 to get the y values
Y_pos <- sqrt(X^2 + Z^2 - 1)  # Positive branch for y
Y_neg <- -sqrt(X^2 + Z^2 - 1) # Negative branch for y
# Remove NA values (where x^2 - y^2 + z^2 < 1, it's undefined)
Y_pos[is.na(Y_pos)] <- 0
Y_neg[is.na(Y_neg)] <- 0
# Open a 3D plot
rgl.open()
# Plot both halves of the hyperboloid
rgl.surface(X, Y_pos, Z, color="lightblue", alpha=0.6)  # Top half
rgl.surface(X, Y_neg, Z, color="lightblue", alpha=0.6)  # Bottom half
# Set viewpoint for interactive rotation
rgl.viewpoint(theta = 40, phi = 30)
# Load the rgl package
library(rgl)
# Define a grid for x and z
x <- seq(-2, 2, length=100)
z <- seq(-2, 2, length=100)
# Create a meshgrid for x and z
X <- outer(x, rep(1, length(z)))
Z <- outer(rep(1, length(x)), z)
# Solve for y^2 = x^2 + z^2 - 1 to get the y values
Y_pos <- sqrt(X^2 + Z^2 - 1)  # Positive branch for y
Y_neg <- -sqrt(X^2 + Z^2 - 1) # Negative branch for y
# Remove NA values (where x^2 - y^2 + z^2 < 1, it's undefined)
Y_pos[is.na(Y_pos)] <- 0
Y_neg[is.na(Y_neg)] <- 0
# Open a 3D plot
rgl.open()
# Plot both halves of the hyperboloid
rgl.surface(X, Y_pos, Z, color="lightblue", alpha=0.6)  # Top half
rgl.surface(X, Y_neg, Z, color="lightblue", alpha=0.6)  # Bottom half
# Set viewpoint for interactive rotation
rgl.viewpoint(theta = 40, phi = 30)
# Load the rgl package
library(rgl)
# Define the parameters
theta <- seq(0, 2*pi, length=100)
phi <- seq(-pi/2, pi/2, length=100)
# Create a meshgrid for theta and phi
Theta <- outer(theta, rep(1, length(phi)))
Phi <- outer(rep(1, length(theta)), phi)
# Parametric equations for the hyperboloids (imaginary surface visualization)
x_top <- cos(Theta) * sqrt(cosh(Phi)^2 - 1)
y_top <- sin(Theta) * sqrt(cosh(Phi)^2 - 1)
z_top <- sinh(Phi)
x_bottom <- cos(Theta) * sqrt(1 - cosh(Phi)^2)
y_bottom <- sin(Theta) * sqrt(1 - cosh(Phi)^2)
z_bottom <- sinh(Phi)
# Open a 3D plot
rgl.open()
# Plot the top part
rgl.surface(x_top, y_top, z_top, color="lightblue", alpha=0.8)
# Plot the bottom part
rgl.surface(x_bottom, y_bottom, z_bottom, color="orange", alpha=0.8)
# Load the rgl package
library(rgl)
# Define a grid for x and z
x <- seq(-2, 2, length=100)
z <- seq(-2, 2, length=100)
# Create a meshgrid for x and z
X <- outer(x, rep(1, length(z)))
Z <- outer(rep(1, length(x)), z)
# Solve for y^2 = x^2 + z^2 to get the y values
Y_pos <- sqrt(X^2 + Z^2)  # Positive branch for y
Y_neg <- -sqrt(X^2 + Z^2) # Negative branch for y
# Open a 3D plot
rgl.open()
# Plot both sheets of the hyperboloid
rgl.surface(X, Y_pos, Z, color="lightblue", alpha=0.6)  # Top sheet
rgl.surface(X, Y_neg, Z, color="lightblue", alpha=0.6)  # Bottom sheet
# Set viewpoint for interactive rotation
rgl.viewpoint(theta = 40, phi = 30)
# Optional: Add axes labels
#rgl.axes()
#rgl.title("Hyperboloid of Two Sheets")
# Load the rgl package
library(rgl)
# Define the parameters
theta <- seq(0, 2*pi, length=100)
phi <- seq(-pi/2, pi/2, length=100)
# Create a meshgrid for theta and phi
Theta <- outer(theta, rep(1, length(phi)))
Phi <- outer(rep(1, length(theta)), phi)
# Parametric equations for the hyperboloids (imaginary surface visualization)
x_top <- cos(Theta) * sqrt(cosh(Phi)^2 - 1)
y_top <- sin(Theta) * sqrt(cosh(Phi)^2 - 1)
z_top <- sinh(Phi)
x_bottom <- cos(Theta) * sqrt(1 - cosh(Phi)^2)
y_bottom <- sin(Theta) * sqrt(1 - cosh(Phi)^2)
z_bottom <- sinh(Phi)
# Open a 3D plot
rgl.open()
# Plot the top part
rgl.surface(x_top, y_top, z_top, color="lightblue", alpha=0.8)
# Plot the bottom part
rgl.surface(x_bottom, y_bottom, z_bottom, color="orange", alpha=0.8)
electricity <- read.csv("Electricity.csv")
electricity <- read.csv("Electricity.csv")
head(electricity)
electricity_prop <- electricity %>%
#filter(County != "KENYA") %>%
mutate(county_title = str_to_title(County),
prop_cases = Access.to.electricity/100)
electricity_prop
electricity_prop <- electricity %>%
#filter(County != "KENYA") %>%
mutate(county_title = str_to_title(County),
prop_electricity_access = Access.to.electricity/100)
electricity_prop
## Map
#View(kenya_counties_sf)
kenya_electricity_map <- kenya_counties_sf %>%
mutate(County = str_remove(County, " CITY")) %>%
left_join(electricity_prop, by = "County")
#View(kenya_results_map)
ggplot(kenya_electricity_map, aes(fill = prop_electricity_access)) +
geom_sf() +
scale_fill_viridis_c(labels = scales::percent) +
theme_void() +
labs(fill = "% of Positive Test Results",
title = "Percentage of Positive Malaria Tests Results as a Fraction of the Total Tests",
subtitle = "KNBS Data 2023",
caption = "<span style='font-size:10pt;'>Source: <b style='color:black;'>Lumumba V.W, 2024</b></span><br>
<span style='color:purple; font-size:9pt;'>Center for Data Analytics & Modeling</span><br>
<span style='color:red; font-size:9pt;'>Chuka University, Kenya</span>") +
theme(plot.caption = ggtext::element_textbox_simple(hjust = 1, halign = 1),
plot.caption.position = "plot")
## Map
#View(kenya_counties_sf)
kenya_electricity_map <- kenya_counties_sf %>%
mutate(County = str_remove(County, " CITY")) %>%
left_join(electricity_prop, by = "County")
#View(kenya_results_map)
ggplot(kenya_electricity_map, aes(fill = prop_electricity_access)) +
geom_sf() +
scale_fill_viridis_c(labels = scales::percent) +
theme_void() +
labs(fill = "% of Electricity Access",
title = "Geospatial Mapping of Access to Electricity Per Counties in Kenya",
subtitle = "Electricity Access",
caption = "<span style='font-size:10pt;'>Source: <b style='color:black;'>Source: OCHA ROSEA, 2024</b></span><br>
<span style='color:purple; font-size:9pt;'>Center for Data Analytics & Modeling</span><br>
<span style='color:red; font-size:9pt;'>Chuka University, Kenya</span>") +
theme(plot.caption = ggtext::element_textbox_simple(hjust = 1, halign = 1),
plot.caption.position = "plot")
electricity <- read.csv("Electricity.csv")
head(electricity)
electricity_prop <- electricity %>%
#filter(County != "KENYA") %>%
mutate(county_title = str_to_title(County),
prop_electricity_access = Access.to.electricity/100)
electricity_prop
## Map
#View(kenya_counties_sf)
kenya_electricity_map <- kenya_counties_sf %>%
mutate(County = str_remove(County, " CITY")) %>%
left_join(electricity_prop, by = "County")
#View(kenya_results_map)
ggplot(kenya_electricity_map, aes(fill = prop_electricity_access)) +
geom_sf() +
scale_fill_viridis_c(labels = scales::percent) +
theme_void() +
labs(fill = "% of Electricity Access",
title = "Geospatial Mapping of Access to Electricity Per Counties in Kenya",
subtitle = "Electricity Access",
caption = "<span style='font-size:10pt;'>Source: <b style='color:black;'>Source: OCHA ROSEA, 2024</b></span><br>
<span style='color:purple; font-size:9pt;'>Center for Data Analytics & Modeling</span><br>
<span style='color:red; font-size:9pt;'>Chuka University, Kenya</span>") +
theme(plot.caption = ggtext::element_textbox_simple(hjust = 1, halign = 1),
plot.caption.position = "plot")
## Map
#View(kenya_counties_sf)
kenya_electricity_map <- kenya_counties_sf %>%
mutate(County = str_remove(County, " CITY")) %>%
left_join(electricity_prop, by = "County")
#View(kenya_results_map)
ggplot(kenya_electricity_map, aes(fill = prop_electricity_access)) +
geom_sf() +
scale_fill_viridis_c(labels = scales::percent) +
theme_void() +
labs(fill = "% of Electricity Access",
title = "Geospatial Mapping of Access to Electricity Per Counties in Kenya",
subtitle = "Electricity Access",
caption = "<span style='font-size:10pt;'>Source: <b style='color:black;'>OCHA ROSEA, 2024</b></span><br>
<span style='color:purple; font-size:9pt;'>Center for Data Analytics & Modeling</span><br>
<span style='color:red; font-size:9pt;'>Chuka University, Kenya</span>") +
theme(plot.caption = ggtext::element_textbox_simple(hjust = 1, halign = 1),
plot.caption.position = "plot")
ggsave("Electricity Access.png")
## Map
#View(kenya_counties_sf)
kenya_electricity_map <- kenya_counties_sf %>%
mutate(County = str_remove(County, " CITY")) %>%
left_join(electricity_prop, by = "County")
#View(kenya_results_map)
ggplot(kenya_electricity_map, aes(fill = prop_electricity_access)) +
geom_sf() +
scale_fill_viridis_c(labels = scales::percent) +
theme_void() +
labs(fill = "% of Electricity Access",
title = "Geospatial Mapping of Access to Electricity Per Counties in Kenya",
subtitle = "Electricity Access",
caption = "<span style='font-size:10pt;'>Source: <b style='color:black;'>OCHA ROSEA, 2024</b></span><br>
<span style='color:purple; font-size:9pt;'>Center for Data Analytics & Modeling</span><br>
<span style='color:red; font-size:9pt;'>Chuka University, Kenya</span>") +
theme(plot.caption = ggtext::element_textbox_simple(hjust = 1, halign = 1),
plot.caption.position = "plot")
ggsave("Electricity Access.png")
## Map
#View(kenya_counties_sf)
kenya_electricity_map <- kenya_counties_sf %>%
mutate(County = str_remove(County, " CITY")) %>%
left_join(electricity_prop, by = "County")
#View(kenya_results_map)
ggplot(kenya_electricity_map, aes(fill = prop_electricity_access)) +
geom_sf() +
scale_fill_viridis_c(labels = scales::percent) +
theme_void() +
labs(fill = "% of Electricity Access",
title = "Geospatial Mapping of Access to Electricity Per Counties in Kenya",
subtitle = "Electricity Access",
caption = "<span style='font-size:10pt;'>Source: <b style='color:black;'>OCHA ROSEA, 2024</b></span><br>
<span style='color:purple; font-size:9pt;'>Center for Data Analytics & Modeling</span><br>
<span style='color:red; font-size:9pt;'>Chuka University, Kenya</span>") +
theme(plot.caption = ggtext::element_textbox_simple(hjust = 1, halign = 1),
plot.caption.position = "plot")
ggsave("Electricity Access.png")
